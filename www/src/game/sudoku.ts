import * as wasm from 'luke-doku-rust';
import {
  AttemptState,
  type DbSymMatch,
  type PuzzleRecord,
} from '../system/database';
import type {PuzzleGeneratedMessage} from '../worker/worker-types';
import {Grid, ReadonlyGrid} from './grid';
import {Loc} from './loc';
import {DateString, GridString} from './types';

/**
 * Describes a Sudoku puzzle.
 */
export class Sudoku {
  constructor(
    readonly clues: ReadonlyGrid,
    /** All the solutions to the given clues. */
    readonly solutions: readonly ReadonlyGrid[],
    /** The possibly multiple ways that the clues conform to grid symmetries. */
    readonly symmetryMatches: readonly SymMatch[],
    /** If it's a puzzle generated by Luke-doku, its ID. */
    readonly id?: PuzzleId,
    /** If it's a puzzle imported from elsewhere, a description of where it comes from. */
    readonly source?: string,
  ) {}

  static fromWorker(puzzle: PuzzleGeneratedMessage, source?: string): Sudoku {
    return new Sudoku(
      new Grid(puzzle.clues),
      puzzle.solutions.map(s => new Grid(s)),
      puzzle.symmetryMatches.map(([sym, match]) => ({
        sym,
        fullOrbits: match.full_orbits.map(orbitToLocs),
        numNonconformingLocs: match.num_nonconforming_locs,
        partialOrbits: match.partial_orbits.map(orbitToLocs),
      })),
      PuzzleId.fromWorker(puzzle),
      source,
    );
  }

  static fromDatabaseRecord(record: PuzzleRecord): Sudoku {
    return new Sudoku(
      new Grid(record.clues),
      record.solutions.map(s => new Grid(s)),
      record.symmetryMatches.map(symMatchFromDb),
      PuzzleId.fromDatabase(record.puzzleId),
      record.source,
    );
  }

  cluesString(): GridString {
    return this.clues.toFlatString();
  }

  toDatabaseRecord(): PuzzleRecord {
    const clues = this.cluesString() as string;
    const solutions = this.solutions.map(g => g.toFlatString() as string);
    const symmetryMatches = symMatchesToDb(this.symmetryMatches);
    const record: PuzzleRecord = {
      clues,
      solutions,
      symmetryMatches,
      attemptState: AttemptState.UNSTARTED,
      lastUpdated: new Date(),
    };
    if (this.id) {
      record.puzzleId = [
        this.id.date,
        this.id.counter,
        this.id.generatorVersion,
      ];
    }
    if (this.source) {
      record.source = this.source;
    }
    return record;
  }
}

/**
 * Identifies a Luke-doku generated puzzle.
 */
export class PuzzleId {
  constructor(
    readonly date: DateString,
    readonly counter: number,
    readonly generatorVersion = 0,
  ) {}

  static fromWorker(message: PuzzleGeneratedMessage): PuzzleId {
    return new PuzzleId(
      message.toWorkerMessage.date as DateString,
      message.toWorkerMessage.counter,
      message.generatorVersion,
    );
  }

  static fromDatabase(
    id: [string, number, number?] | undefined,
  ): PuzzleId | undefined {
    return id ? new PuzzleId(id[0] as DateString, id[1], id[2]) : undefined;
  }

  toString(): string {
    return `${this.date}:${this.counter}:${this.generatorVersion ?? 0}`;
  }
}

/**
 * The wasm code matches the possible symmetries of the Sudoku board against the
 * clues of a given puzzle to produce one or more of these objects.
 */
export declare interface SymMatch {
  readonly sym: wasm.Sym;
  readonly fullOrbits: Loc[][];
  readonly numNonconformingLocs: number;
  readonly partialOrbits: Loc[][];
}

function orbitToLocs(orbit: number[] | Int8Array): Loc[] {
  return Array.prototype.map.call(orbit, index => Loc.of(index)) as Loc[];
}

function symMatchFromDb(match: DbSymMatch): SymMatch {
  return {
    sym: match.sym,
    fullOrbits: match.fullOrbits.map(orbitToLocs),
    numNonconformingLocs: match.numNonconformingLocs,
    partialOrbits: match.partialOrbits.map(orbitToLocs),
  };
}

// We convert all matches together so that all the Int8Arrays can share the same
// underlying buffer.
function symMatchesToDb(matches: readonly SymMatch[]): DbSymMatch[] {
  const bytesInput: number[] = [];
  for (const match of matches) {
    appendBytes(match.fullOrbits, bytesInput);
    appendBytes(match.partialOrbits, bytesInput);
  }
  // This array has all the orbits of all the matches.
  const bytes = new Int8Array(bytesInput);
  let offset = 0;
  const answer: DbSymMatch[] = [];
  for (const match of matches) {
    const dbMatch: DbSymMatch = {
      sym: match.sym,
      fullOrbits: [],
      numNonconformingLocs: match.numNonconformingLocs,
      partialOrbits: [],
    };
    offset = appendOrbits(bytes, offset, match.fullOrbits, dbMatch.fullOrbits);
    offset = appendOrbits(
      bytes,
      offset,
      match.partialOrbits,
      dbMatch.partialOrbits,
    );
    answer.push(dbMatch);
  }
  return answer;
}

function appendBytes(orbits: Loc[][], array: number[]) {
  for (const orbit of orbits) {
    array.push(...orbit.map(loc => loc.index));
  }
}

function appendOrbits(
  bytes: Int8Array,
  offset: number,
  orbits: Loc[][],
  array: Int8Array[],
): number {
  for (const orbit of orbits) {
    array.push(bytes.subarray(offset, (offset += orbit.length)));
  }
  return offset;
}
